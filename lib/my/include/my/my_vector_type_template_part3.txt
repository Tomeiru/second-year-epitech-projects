/*
** EPITECH PROJECT, 2022
** libmy
** File description:
** Part 3 of my_vector_type_template
*/

#pragma once

#include "MY_INTERNAL_FILENAME_COMPOSER_part4.h"

// Append size items from data to self
static inline struct MY_INTERNAL_TYPE_TOKEN *
    MY_REM_SPACE_AFTER_TYPE_TOKEN _append(
    struct MY_INTERNAL_TYPE_TOKEN *self,
    MY_CONST_VECTOR_TYPE *data,
    size_t size)
{
    return MY_REM_SPACE_AFTER_TYPE_TOKEN _insert(self, data, size, self->size);
}

// Same as append, but for a single item
static inline struct MY_INTERNAL_TYPE_TOKEN *
    MY_REM_SPACE_AFTER_TYPE_TOKEN _append_single(
    struct MY_INTERNAL_TYPE_TOKEN *self,
    MY_VECTOR_TYPE item)
{
    return MY_REM_SPACE_AFTER_TYPE_TOKEN _append(self, &item, 1);
}

// Creates a new vector from the given data (which has size items)
MY_ATTR_WARN_UNUSED_RESULT static inline
    struct MY_INTERNAL_TYPE_TOKEN *
    MY_REM_SPACE_AFTER_TYPE_TOKEN _new_from_data
    (MY_CONST_VECTOR_TYPE *data,
    size_t size)
{
    struct MY_INTERNAL_TYPE_TOKEN *self =
        MY_REM_SPACE_AFTER_TYPE_TOKEN _new();

    if (data)
        MY_REM_SPACE_AFTER_TYPE_TOKEN _append(self, data, size);
    return self;
}

// Resizes data to contain size items. If the current size is less than the
// given one, the vector becomes bigger, but has undefined contents after the
// current size. If the current size is greater than the given one, the vector
// is reduced to its first size elements
static inline struct MY_INTERNAL_TYPE_TOKEN *
    MY_REM_SPACE_AFTER_TYPE_TOKEN _resize(
    struct MY_INTERNAL_TYPE_TOKEN *self,
    size_t size)
{
    if (self == NULL)
        return NULL;
    if (size >= self->allocated_size)
        MY_REM_SPACE_AFTER_TYPE_TOKEN _guarantee_can_expand(self,
            size - self->size);
    self->size = size;
    return self;
}
